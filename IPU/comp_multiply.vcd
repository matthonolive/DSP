$date
	Thu Feb 06 16:33:47 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_comp_multiply $end
$var wire 64 ! result [63:0] $end
$var reg 64 " a [63:0] $end
$var reg 64 # b [63:0] $end
$scope module dut $end
$var wire 64 $ a [63:0] $end
$var wire 64 % b [63:0] $end
$var wire 64 & result [63:0] $end
$var wire 32 ' r [31:0] $end
$var wire 32 ( q [31:0] $end
$var wire 32 ) da [31:0] $end
$var wire 32 * bd [31:0] $end
$var wire 32 + bc [31:0] $end
$var wire 32 , ac [31:0] $end
$var parameter 32 - double $end
$var parameter 32 . size $end
$scope module complex_inst $end
$var wire 1 / sign_b $end
$var wire 1 0 sign_a $end
$var wire 32 1 result [31:0] $end
$var wire 24 2 frac_b [23:0] $end
$var wire 24 3 frac_a [23:0] $end
$var wire 8 4 exp_b [7:0] $end
$var wire 1 5 exp_a_gt_exp_b $end
$var wire 8 6 exp_a [7:0] $end
$var wire 32 7 b [31:0] $end
$var wire 32 8 a [31:0] $end
$var parameter 32 9 double $end
$var parameter 32 : exponent $end
$var parameter 32 ; mantissa $end
$var parameter 32 < size $end
$var reg 25 = aligned_frac_a [24:0] $end
$var reg 25 > aligned_frac_b [24:0] $end
$var reg 25 ? diff_mantissa [24:0] $end
$var reg 8 @ exp_diff [7:0] $end
$var reg 1 A found $end
$var reg 8 B new_exp [7:0] $end
$var reg 1 C new_sign_bit $end
$scope begin $ivl_for_loop0 $end
$var integer 32 D i [31:0] $end
$upscope $end
$upscope $end
$scope module mult_inst1 $end
$var wire 32 E a [31:0] $end
$var wire 32 F b [31:0] $end
$var wire 1 G sign_b $end
$var wire 1 H sign_a $end
$var wire 32 I result [31:0] $end
$var wire 24 J frac_b [23:0] $end
$var wire 24 K frac_a [23:0] $end
$var wire 8 L exp_b [7:0] $end
$var wire 8 M exp_a [7:0] $end
$var parameter 32 N bias $end
$var parameter 32 O double $end
$var parameter 32 P exponent $end
$var parameter 32 Q mantissa $end
$var parameter 32 R size $end
$var reg 48 S diff_mantissa [47:0] $end
$var reg 1 T found $end
$var reg 9 U new_exp [8:0] $end
$var reg 1 V new_sign_bit $end
$scope begin $ivl_for_loop1 $end
$var integer 32 W i [31:0] $end
$upscope $end
$upscope $end
$scope module mult_inst2 $end
$var wire 32 X a [31:0] $end
$var wire 32 Y b [31:0] $end
$var wire 1 Z sign_b $end
$var wire 1 [ sign_a $end
$var wire 32 \ result [31:0] $end
$var wire 24 ] frac_b [23:0] $end
$var wire 24 ^ frac_a [23:0] $end
$var wire 8 _ exp_b [7:0] $end
$var wire 8 ` exp_a [7:0] $end
$var parameter 32 a bias $end
$var parameter 32 b double $end
$var parameter 32 c exponent $end
$var parameter 32 d mantissa $end
$var parameter 32 e size $end
$var reg 48 f diff_mantissa [47:0] $end
$var reg 1 g found $end
$var reg 9 h new_exp [8:0] $end
$var reg 1 i new_sign_bit $end
$scope begin $ivl_for_loop1 $end
$var integer 32 j i [31:0] $end
$upscope $end
$upscope $end
$scope module mult_inst3 $end
$var wire 32 k a [31:0] $end
$var wire 32 l b [31:0] $end
$var wire 1 m sign_b $end
$var wire 1 n sign_a $end
$var wire 32 o result [31:0] $end
$var wire 24 p frac_b [23:0] $end
$var wire 24 q frac_a [23:0] $end
$var wire 8 r exp_b [7:0] $end
$var wire 8 s exp_a [7:0] $end
$var parameter 32 t bias $end
$var parameter 32 u double $end
$var parameter 32 v exponent $end
$var parameter 32 w mantissa $end
$var parameter 32 x size $end
$var reg 48 y diff_mantissa [47:0] $end
$var reg 1 z found $end
$var reg 9 { new_exp [8:0] $end
$var reg 1 | new_sign_bit $end
$scope begin $ivl_for_loop1 $end
$var integer 32 } i [31:0] $end
$upscope $end
$upscope $end
$scope module mult_inst4 $end
$var wire 32 ~ a [31:0] $end
$var wire 32 !" b [31:0] $end
$var wire 1 "" sign_b $end
$var wire 1 #" sign_a $end
$var wire 32 $" result [31:0] $end
$var wire 24 %" frac_b [23:0] $end
$var wire 24 &" frac_a [23:0] $end
$var wire 8 '" exp_b [7:0] $end
$var wire 8 (" exp_a [7:0] $end
$var parameter 32 )" bias $end
$var parameter 32 *" double $end
$var parameter 32 +" exponent $end
$var parameter 32 ," mantissa $end
$var parameter 32 -" size $end
$var reg 48 ." diff_mantissa [47:0] $end
$var reg 1 /" found $end
$var reg 9 0" new_exp [8:0] $end
$var reg 1 1" new_sign_bit $end
$scope begin $ivl_for_loop1 $end
$var integer 32 2" i [31:0] $end
$upscope $end
$upscope $end
$scope module real_inst $end
$var wire 32 3" a [31:0] $end
$var wire 32 4" b [31:0] $end
$var wire 1 5" sign_b $end
$var wire 1 6" sign_a $end
$var wire 32 7" result [31:0] $end
$var wire 24 8" frac_b [23:0] $end
$var wire 24 9" frac_a [23:0] $end
$var wire 8 :" exp_b [7:0] $end
$var wire 1 ;" exp_a_gt_exp_b $end
$var wire 8 <" exp_a [7:0] $end
$var parameter 32 =" double $end
$var parameter 32 >" exponent $end
$var parameter 32 ?" mantissa $end
$var parameter 32 @" size $end
$var reg 25 A" aligned_frac_a [24:0] $end
$var reg 25 B" aligned_frac_b [24:0] $end
$var reg 25 C" diff_mantissa [24:0] $end
$var reg 8 D" exp_diff [7:0] $end
$var reg 1 E" found $end
$var reg 8 F" new_exp [7:0] $end
$var reg 1 G" new_sign_bit $end
$scope begin $ivl_for_loop0 $end
$var integer 32 H" i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 @"
b10111 ?"
b1000 >"
b0 ="
b100000 -"
b10111 ,"
b1000 +"
b0 *"
b1111111 )"
b100000 x
b10111 w
b1000 v
b0 u
b1111111 t
b100000 e
b10111 d
b1000 c
b0 b
b1111111 a
b100000 R
b10111 Q
b1000 P
b0 O
b1111111 N
b100000 <
b10111 ;
b1000 :
b0 9
b100000 .
b0 -
$end
#0
$dumpvars
bx H"
xG"
b0 F"
xE"
b0 D"
bx C"
b0xxxxxxxxxxxxxxxxxxxxxxx B"
b0xxxxxxxxxxxxxxxxxxxxxxx A"
b0 <"
0;"
b0 :"
b0xxxxxxxxxxxxxxxxxxxxxxx 9"
b0xxxxxxxxxxxxxxxxxxxxxxx 8"
bx00000000xxxxxxxxxxxxxxxxxxxxxxx 7"
x6"
15"
b100000000xxxxxxxxxxxxxxxxxxxxxxx 4"
bx00000000xxxxxxxxxxxxxxxxxxxxxxx 3"
bx 2"
x1"
b0 0"
x/"
bx ."
bx ("
bx '"
bx &"
bx %"
bx00000000xxxxxxxxxxxxxxxxxxxxxxx $"
x#"
x""
bx !"
bx ~
bx }
x|
b0 {
xz
bx y
bx s
bx r
bx q
bx p
bx00000000xxxxxxxxxxxxxxxxxxxxxxx o
xn
xm
bx l
bx k
bx j
xi
b0 h
xg
bx f
bx `
bx _
bx ^
bx ]
bx00000000xxxxxxxxxxxxxxxxxxxxxxx \
x[
xZ
bx Y
bx X
bx W
xV
b0 U
xT
bx S
bx M
bx L
bx K
bx J
bx00000000xxxxxxxxxxxxxxxxxxxxxxx I
xH
xG
bx F
bx E
bx D
xC
b0 B
xA
b0 @
bx ?
b0xxxxxxxxxxxxxxxxxxxxxxx >
b0xxxxxxxxxxxxxxxxxxxxxxx =
bx00000000xxxxxxxxxxxxxxxxxxxxxxx 8
bx00000000xxxxxxxxxxxxxxxxxxxxxxx 7
b0 6
05
b0 4
b0xxxxxxxxxxxxxxxxxxxxxxx 3
b0xxxxxxxxxxxxxxxxxxxxxxx 2
bx00000000xxxxxxxxxxxxxxxxxxxxxxx 1
x0
x/
bx00000000xxxxxxxxxxxxxxxxxxxxxxx ,
bx00000000xxxxxxxxxxxxxxxxxxxxxxx +
bx00000000xxxxxxxxxxxxxxxxxxxxxxx *
bx00000000xxxxxxxxxxxxxxxxxxxxxxx )
bx00000000xxxxxxxxxxxxxxxxxxxxxxx (
bx00000000xxxxxxxxxxxxxxxxxxxxxxx '
bx00000000xxxxxxxxxxxxxxxxxxxxxxxx00000000xxxxxxxxxxxxxxxxxxxxxxx &
bx %
bx $
bx #
bx "
bx00000000xxxxxxxxxxxxxxxxxxxxxxxx00000000xxxxxxxxxxxxxxxxxxxxxxx !
$end
#5000
0G"
b0 C"
b101000111101011100001010 B"
b101000111101011100001010 A"
0A
b101000111101011100001010 ?
b101000111101011100001010 >
b101000111101011100001010 =
b101000111101011100001010 8"
b101000111101011100001010 9"
b0 '
b0 7"
b0 F"
b101000111101011100001010 3
b101000111101011100001010 2
b1111001 B
b1111000 :"
0;"
b1111000 <"
b1111000 6
b1111000 4
b10111100001000111101011100001010 4"
b111100101000111101011100001010 !
b111100101000111101011100001010 &
b111100101000111101011100001010 (
b111100101000111101011100001010 1
0C
b110000 W
1T
b101000111101011100001010100011110101110000101001 S
b110000 j
1g
b101000111101011100001010100011110101110000101001 f
b110000 }
1z
b101000111101011100001010100011110101110000101001 y
b110000 2"
1/"
b101000111101011100001010100011110101110000101001 ."
06"
00
0/
b110011001100110011001101 J
b110011001100110011001101 ]
b110011001100110011001101 p
b110011001100110011001101 %"
b1111000 U
b111100001000111101011100001010 ,
b111100001000111101011100001010 I
b111100001000111101011100001010 3"
0V
b110011001100110011001101 K
b1111000 h
b111100001000111101011100001010 +
b111100001000111101011100001010 8
b111100001000111101011100001010 \
0i
b110011001100110011001101 ^
b1111000 {
b111100001000111101011100001010 )
b111100001000111101011100001010 7
b111100001000111101011100001010 o
0|
b110011001100110011001101 q
b1111000 0"
b111100001000111101011100001010 *
b111100001000111101011100001010 $"
01"
b110011001100110011001101 &"
0G
b1111011 L
0Z
b1111011 _
0m
b1111011 r
0""
b1111011 '"
0H
b1111011 M
0[
b1111011 `
0n
b1111011 s
0#"
b1111011 ("
b111101110011001100110011001101 F
b111101110011001100110011001101 Y
b111101110011001100110011001101 l
b111101110011001100110011001101 !"
b111101110011001100110011001101 E
b111101110011001100110011001101 X
b111101110011001100110011001101 k
b111101110011001100110011001101 ~
b11110111001100110011001100110100111101110011001100110011001101 #
b11110111001100110011001100110100111101110011001100110011001101 %
b11110111001100110011001100110100111101110011001100110011001101 "
b11110111001100110011001100110100111101110011001100110011001101 $
#15000
